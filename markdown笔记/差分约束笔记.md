# 【图论】差分约束系统

## 基本概念

差分约束系统是下面这种形式的多元一次不等式组：
$$
\begin{cases}
x_{c_1}-x_{c'_1}\leq y_1 \\
x_{c_2}-x_{c'_2}\leq y_2 \\
\cdots \\
x_{c_m} - x_{c'_m}\leq y_m
\end{cases}
$$

每个不等式称为一个约束条件，都是两个未知量之差小于或等于某个常数。

## 算法原理

### 转化为最短路问题

对于每个不等式 $x_i - x_j \leq c_k$，可以变形为 $x_i \leq x_j + c_k$。

这与单源最短路中的三角形不等式 $dist[y] \leq dist[x] + w_{x,y}$ 非常相似。

因此，我们可以：
1. 将每个变量 $x_i$ 看作图中的一个顶点
2. 对于每个约束条件 $x_i - x_j \leq c_k$，从顶点 $j$ 向顶点 $i$ 连一条长度为 $c_k$ 的有向边

### 求解步骤

1. 将每个不等式 $x_i \leq x_j + c_k$ 转化成一条从 $x_j$ 到 $x_i$ 长度为 $c_k$ 的一条边
2. 找一个超级源点，使其可以遍历到所有点（通常新建一个0号点）
3. 从源点求一遍单源最短路
   - 如果存在负环，则原不等式组一定无解
   - 如果无负环，则 $dist[i]$ 就是原不等式组的一个可行解

### 求最大值或最小值

- 如果求的是最小值，则应该求最长路
- 如果求的是最大值，则应该求最短路

## C++实现（SPFA算法）

### 最短路版本（求最大值）

```cpp
#include <iostream>
#include <queue>
#include <cstring>
#include <vector>
using namespace std;

const int MAXN = 5005;
const int MAXM = 10005;
const int INF = 0x3f3f3f3f;

struct Edge {
    int to, next, w;
} edges[MAXM];

int cnt_edge, head[MAXN];
bool inqueue[MAXN];
int cnt[MAXN], dis[MAXN];
queue<int> q;

void add_edge(int from, int to, int w) {
    edges[++cnt_edge].next = head[from];
    edges[cnt_edge].to = to;
    edges[cnt_edge].w = w;
    head[from] = cnt_edge;
}

bool SPFA(int s, int n) {
    memset(dis, 0x3f, sizeof(dis));
    dis[s] = 0;
    q.push(s);
    inqueue[s] = true;
    
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        inqueue[u] = false;
        
        for (int i = head[u]; i != 0; i = edges[i].next) {
            int v = edges[i].to;
            if (dis[v] > dis[u] + edges[i].w) {
                dis[v] = dis[u] + edges[i].w;
                if (!inqueue[v]) {
                    q.push(v);
                    inqueue[v] = true;
                    cnt[v]++;
                    if (cnt[v] > n) return false; // 存在负环
                }
            }
        }
    }
    return true;
}

int main() {
    int n, m;
    cin >> n >> m;
    
    for (int i = 0; i < m; ++i) {
        int x, y, w;
        cin >> x >> y >> w;
        add_edge(y, x, w); // x - y <= w => y -> x 权值为w
    }
    
    // 建立超级源点
    for (int i = 1; i <= n; ++i) {
        add_edge(0, i, 0);
    }
    
    if (SPFA(0, n)) {
        for (int i = 1; i <= n; ++i) {
            cout << dis[i] << " ";
        }
        cout << endl;
    } else {
        cout << "NO" << endl; // 无解
    }
    
    return 0;
}
```

### 最长路版本（求最小值）

```cpp
#include <iostream>
#include <queue>
#include <cstring>
#include <vector>
using namespace std;

const int MAXN = 5005;
const int MAXM = 10005;
const int INF = 0x3f3f3f3f;

struct Edge {
    int to, next, w;
} edges[MAXM];

int cnt_edge, head[MAXN];
bool inqueue[MAXN];
int cnt[MAXN], dis[MAXN];
queue<int> q;

void add_edge(int from, int to, int w) {
    edges[++cnt_edge].next = head[from];
    edges[cnt_edge].to = to;
    edges[cnt_edge].w = w;
    head[from] = cnt_edge;
}

bool SPFA(int s, int n) {
    memset(dis, -0x3f, sizeof(dis));
    dis[s] = 0;
    q.push(s);
    inqueue[s] = true;
    
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        inqueue[u] = false;
        
        for (int i = head[u]; i != 0; i = edges[i].next) {
            int v = edges[i].to;
            if (dis[v] < dis[u] + edges[i].w) { // 注意这里是小于号
                dis[v] = dis[u] + edges[i].w;
                if (!inqueue[v]) {
                    q.push(v);
                    inqueue[v] = true;
                    cnt[v]++;
                    if (cnt[v] > n) return false; // 存在正环
                }
            }
        }
    }
    return true;
}

int main() {
    int n, m;
    cin >> n >> m;
    
    for (int i = 0; i < m; ++i) {
        int x, y, w;
        cin >> x >> y >> w;
        add_edge(y, x, w); // x - y >= w => y -> x 权值为w
    }
    
    // 建立超级源点
    for (int i = 1; i <= n; ++i) {
        add_edge(0, i, 0);
    }
    
    if (SPFA(0, n)) {
        for (int i = 1; i <= n; ++i) {
            cout << dis[i] << " ";
        }
        cout << endl;
    } else {
        cout << "NO" << endl; // 无解
    }
    
    return 0;
}
```

## 不等式转换技巧

1. $x_1 - x_2 \geq y$ → 转化为 $x_2 - x_1 \leq -y$
2. $x_1 - x_2 = y$ → 转化为 $x_1 - x_2 \leq y \wedge x_2 - x_1 \leq y$
3. $x_1 - x_2 < y$ → 转化为 $x_1 - x_2 \leq y-1$ （整数情形）
4. $x_1 - x_2 > y$ → 转化为 $x_2 - x_1 \leq -y-1$

## 经典问题与洛谷链接

### 1. [P5960 【模板】差分约束算法](https://www.luogu.com.cn/problem/P5960)

**题目描述**：给出一组包含 m 个不等式，有 n 个未知数的形如差分约束系统，求任意一组满足这个不等式组的解。

**解题思路**：直接套用差分约束模板，建图后跑SPFA判断负环。

### 2. [P1993 小K的农场](https://www.luogu.com.cn/problem/P1993)

**题目描述**：给定一些关系，判断是否存在矛盾。

**解题思路**：
- $x_i - x_j \leq c$ → $j \rightarrow i$ 权值为 $c$
- $x_i - x_j \geq c$ → $j \rightarrow i$ 权值为 $-c$
- $x_i = x_j$ → $i \rightarrow j$ 权值为 $0$，$j \rightarrow i$ 权值为 $0$

### 3. [P3275 [SCOI2011]糖果](https://www.luogu.com.cn/problem/P3275)

**题目描述**：有N个小朋友，要求每个人都得到糖果，且每个人的糖果总数满足一定的关系式，求至少共分给小朋友们多少糖果。

**解题思路**：
- $A = B$ → $A \rightarrow B$ 权值为 $0$，$B \rightarrow A$ 权值为 $0$
- $A < B$ → $B \rightarrow A$ 权值为 $1$
- $A \geq B$ → $B \rightarrow A$ 权值为 $0$
- $A > B$ → $A \rightarrow B$ 权值为 $1$
- $A \leq B$ → $A \rightarrow B$ 权值为 $0$

### 4. [P4926 [1007]倍杀测量者](https://www.luogu.com.cn/problem/P4926)

**题目描述**：给定一些选手的分数关系，求最大的正实数T使得限制条件仍然成立。

**解题思路**：这是一个较为复杂的差分约束问题，需要二分答案，然后判断是否存在可行解。

### 5. [P1250 种树](https://www.luogu.com.cn/problem/P1250)

**题目描述**：一条街的一边有几座房子，每个居民想在门前种些树并指定了三个号码B，E，T，表示该居民想在B和E之间最少种T棵树。

**解题思路**：设 $sum[i]$ 表示前 $i$ 块地种的树的数量，则：
- $sum[E] - sum[B-1] \geq T$
- $0 \leq sum[i] - sum[i-1] \leq 1$

### 6. [P2294 [HNOI2005]狡猾的商人](https://www.luogu.com.cn/problem/P2294)

**题目描述**：给出一些月份的总收入，判断这些数据是否矛盾。

**解题思路**：设 $sum[i]$ 表示前 $i$ 个月的总收入，则 $sum[j] - sum[i-1] = w$ 可以转化为两个不等式。

## 常用技巧

1. **超级源点**：当图不连通时，建立一个超级源点（如0号点），向所有点连一条边权为0的边。

2. **判负环**：使用SPFA时，记录每个点入队次数，如果超过n次则存在负环。

3. **初始化**：
   - 求最短路时，初始化为正无穷
   - 求最长路时，初始化为负无穷

4. **栈优化**：在某些题目中，使用栈代替队列可以避免被卡。

5. **SLF优化**：使用双端队列，对新节点进行判断，如果距离比队头小则插入队头，否则插入队尾。

## 复杂度分析

- 时间复杂度：最坏情况下为 $O(nm)$，但实际应用中通常表现良好
- 空间复杂度：$O(n+m)$

## 总结

差分约束系统是解决一类特殊不等式组的有效方法，核心思想是将不等式转化为图论中的最短路问题。关键在于正确建图和选择合适的算法（最短路或最长路）。