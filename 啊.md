[啊哈！](edu.ahacode.com)
### 作业完成情况
day2-test 29.Jan 2026 190/200 订正后300/500 4/5
#### 28.Jan 2026
```plaintext
day1-3 0/2 0/200 (12:39 29.Jan 2026) 修改后100/200
day1-2 2/2 170/200  样例有误 => 200/200 ok tarjan正解修改后200/200 (29.Jan 2026)
day1-1 0/1 0/100
day1-test 测试 2/5 200/500
```
#### 24.Jan 2026
```plaintext
day5test 2/4 200/400
```
## $My\ account$
**Username**: 王钟毓\
**Pasword**: 123456\
**School ID**: 0270023

### Notebook
割点朴素算法： `n`为点数，`m`为边数, m行从`u->v v->u`双向边 (28.Jan 2026)
```cpp
#include <bits/stdc++.h>
using namespace std;

vector<int> g[105];
int vis[105];

void dfs(int u) {
	for (auto v : g[u]) {
		if (!vis[v]) {
			vis[v] = true;
			dfs(v);
		}
	}
}

int main()
{
	// O(N * (N + M))
	int n, m;
	cin >> n >> m;
	vector<int> ans;
	for (int i = 1; i <= m; i++) {
		int u, v;
		cin >> u >> v;
		g[u].push_back(v);
		g[v].push_back(u);
	}
	for (int i = 1; i <= n; i++) {
		memset(vis, 0, sizeof vis);
		vis[i] = true;
		if (i != 1) dfs(1);
		else dfs(2);
		bool flag = true;
		for (int j = 1; j <= n; j++) {
			if (!vis[j]) {
				flag = false;
				break;
			}
		}
		if(!flag) {
			ans.push_back(i);
		}
	}
	if (ans.empty()) cout << "None"; // 没有割点
	else for (auto i : ans) cout << i << ' ';
    return 0;
}

```
割边朴素算法： `n`为点数，`m`为边数, m行从`u->v v->u`双向边 (28.Jan 2026)
```cpp
#include <bits/stdc++.h>
#define U first
#define V second
using namespace std;
//5.1
vector<int> g[105];
int vis[105];
pair<int, int> a[105];

void dfs(int u, pair<int, int> x) {
	for (int v : g[u]) {
		if (!vis[v] && !(x.U == u && x.V == v) && !(x.U == v && x.V == u)) {
			vis[v] = true;
			dfs(v, x);
		}
	}
}

int main()
{
	// O(m * (N + M))
	int n, m;
	cin >> n >> m;
	for (int i = 1; i <= m; i++) {
		int u, v;
		cin >> u >> v;
		a[i] = {u, v};
		g[u].push_back(v);
		g[v].push_back(u);
	}
	vector<pair<int,int>> ans;
	for (int i = 1; i <= m; i++) {
		memset(vis, 0, sizeof vis);
		vis[1] = true;
		dfs(1, a[i]);
		bool flag = true;
		for (int j = 1; j <= n; j++) {
			if (!vis[j]) {
				flag = false;
				break;
			}
		}
		if(!flag) {
			ans.push_back(a[i]);
		}
	}
	if (ans.empty()) cout << "None"; // 没有割边
	else for (auto p : ans) {   
	    int u = p.U, v = p.V;
	    cout << u << "-" << v << '\n';
	}
    return 0;
}
```
割点的tarjan算法
```cpp
#include <bits/stdc++.h>
using namespace std;

vector<int> g[105];
int idx = 0, n, m, low[105], dfn[105], root_sons = 0;
int flag[105];

void dfs(int u, int fa)
{
    cerr << u;
    dfn[u] = ++idx; // 时间戳
    low[u] = idx; // 当前顶点能够访问的到的最小顶点的时间戳
    for (int v : g[u]) {
        if (!dfn[v]) { // 用时间戳代替book数组，当时间戳0是说明没访问
            dfs(v, u);
            if (u == 1)
                root_sons++;
            low[u] = min(low[u], low[v]);
            if (low[v] >= dfn[u] && u != 1) // 当前节点不是根节点且当前儿子的v比当前节点的时间戳还要>=就是割点
                flag[u] = 1;
        } else if (v != fa) {
            // 否则如果当前儿子曾经访问过但也不是当前节点的父节点，则说明                                                                                                                                               \
               此时的v为u的祖先，因此要更新当前节点u的low值
            low[u] = min(low[u], dfn[v]);
        }
    }
}

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= m; i++) {
        int u, v;
        cin >> u >> v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    dfs(1, 1);
    if (root_sons >= 2)
        flag[1] = 1;
    else
        flag[1] = 0;
    bool falg = false;
    for (int i = 1; i <= n; i++)
        if (flag[i]) {
            cout << i << " ";
            falg = true;
        }
    if (!falg)
        cout << "None";
    return 0;
}
```
割边的tarjan算法
```cpp
#include <bits/stdc++.h>
using namespace std;

vector<int> g[105];
int idx = 0, n, m, low[105], dfn[105];
vector<pair<int, int>> ans;

void dfs(int u, int fa)
{
    dfn[u] = ++idx; // 时间戳
    low[u] = idx; // 当前顶点能够访问的到的最小顶点的时间戳
    for (int v : g[u]) {
        if (!dfn[v]) { // 用时间戳代替book数组，当时间戳0是说明没访问
            dfs(v, u);
            low[u] = min(low[u], low[v]);
            // 如果low[v] > dfn[u] 就说明只有一条路径通向父亲节点，即为割边
            if (low[v] > dfn[u]) {
                ans.push_back({ u, v });
            }
        } else if (v != fa) {
            // 否则如果当前儿子曾经访问过但也不是当前节点的父节点，则说明                                                                                                                                               \
               此时的v为u的祖先，因此要更新当前节点u的low值
            low[u] = min(low[u], dfn[v]);
        }
    }
}

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= m; i++) {
        int u, v;
        cin >> u >> v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    dfs(1, 1);
    sort(ans.begin(), ans.end());
    for (auto i : ans) {
        cout << i.first << "-" << i.second << '\n';
    }
    if (ans.empty())
        cout << "None";
    return 0;
}
```
### History

20.Dec 2025 并查集 && 最小生成树($Kruskal$)\
27.Dec 2025 二分图（匈牙利算法）\
10.Jan 2026 二分图应用 （依旧二分图）\
17.Jan 2026 二分图（依旧二分图） && $test$ \
24.Jan 2026 test （二分图test）\
\
**28.Jan to 30.Jan** 为经开集训体验 \
28.Jan 2026 图的割点与割边 **只有朴素算法**\
29.Jan 2026 图的割点与割边 使用`tarjan`的算法 day2-test \
    第一题 0 / 100 差分约束 \
    第二题 90 / 0 dfs暴力 \
    第三题 80 / 40 订正有问题 倒序bfs \
    第四题 0 / 30 订正需要LCA不会 基于边的双连通分量+缩点建树+q次询问求a->b的距离(正解为LCA, 暴力30) \
    第五题 0 / 0  基于点的双连通分量不会
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
咕咕咕咕嘎嘎321321